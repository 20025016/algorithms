{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"data-structures/arrays/","text":"Arrays Description An array is a linear data structure stored in a contiguous memory block. Each value is adjacent to one another. The time complexity for accessing data within an array is O(1). Arrays can store multiple data values under a single variable. Example Code import numpy as np arr = np.array([1, 2, 3, 4, 5]) print(arr) print(type(arr)) Usage Creating an array requires using either NumPy or an inbuilt Python array class. NumPy arrays are simple, initiate the array class and pass the values to be stored. Accessing data from a NumPy array requires an index of the value stored, the same method of accessing a list. Additional Numpy array documentation is here . Python array documentation is here .","title":"Arrays"},{"location":"data-structures/arrays/#arrays","text":"","title":"Arrays"},{"location":"data-structures/arrays/#description","text":"An array is a linear data structure stored in a contiguous memory block. Each value is adjacent to one another. The time complexity for accessing data within an array is O(1). Arrays can store multiple data values under a single variable.","title":"Description"},{"location":"data-structures/arrays/#example-code","text":"import numpy as np arr = np.array([1, 2, 3, 4, 5]) print(arr) print(type(arr))","title":"Example Code"},{"location":"data-structures/arrays/#usage","text":"Creating an array requires using either NumPy or an inbuilt Python array class. NumPy arrays are simple, initiate the array class and pass the values to be stored. Accessing data from a NumPy array requires an index of the value stored, the same method of accessing a list. Additional Numpy array documentation is here . Python array documentation is here .","title":"Usage"},{"location":"data-structures/graphs/","text":"Graphs Description Graphs data structure formed from vertices/nodes. To connect the vertices/nodes is to use edges. Both vertices/edges can have labels for easier identification. The time complexity for data heavily depends on the number of vertices and edges in the graph. The Big O notation for accessing is O(V+E). Graphs used to represent networks, graphs used within social networks such as Facebook and Linkedin. In social media, each node can be a person. Example Code # Code example from https://www.bogotobogo.com/python/python_graph_data_structures.php class Vertex: def __init__(self, node): self.id = node self.adjacent = {} def __str__(self): return str(self.id) + ' adjacent: ' + str([x.id for x in self.adjacent]) def add_neighbor(self, neighbor, weight=0): self.adjacent[neighbor] = weight def get_connections(self): return self.adjacent.keys() def get_id(self): return self.id def get_weight(self, neighbor): return self.adjacent[neighbor] class Graph: def __init__(self): self.vert_dict = {} self.num_vertices = 0 def __iter__(self): return iter(self.vert_dict.values()) def add_vertex(self, node): self.num_vertices = self.num_vertices + 1 new_vertex = Vertex(node) self.vert_dict[node] = new_vertex return new_vertex def get_vertex(self, n): if n in self.vert_dict: return self.vert_dict[n] else: return None def add_edge(self, frm, to, cost = 0): if frm not in self.vert_dict: self.add_vertex(frm) if to not in self.vert_dict: self.add_vertex(to) self.vert_dict[frm].add_neighbor(self.vert_dict[to], cost) self.vert_dict[to].add_neighbor(self.vert_dict[frm], cost) def get_vertices(self): return self.vert_dict.keys() if __name__ == '__main__': g = Graph() g.add_vertex('a') g.add_vertex('b') g.add_vertex('c') g.add_vertex('d') g.add_vertex('e') g.add_vertex('f') g.add_edge('a', 'b', 7) g.add_edge('a', 'c', 9) g.add_edge('a', 'f', 14) g.add_edge('b', 'c', 10) g.add_edge('b', 'd', 15) g.add_edge('c', 'd', 11) g.add_edge('c', 'f', 2) g.add_edge('d', 'e', 6) g.add_edge('e', 'f', 9) for v in g: for w in v.get_connections(): vid = v.get_id() wid = w.get_id() print(('( %s , %s, %3d)' % ( vid, wid, v.get_weight(w)))) for v in g: print(('g.vert_dict[%s]=%s' %(v.get_id(), g.vert_dict[v.get_id()]))) Usage To use this graph data structure, you need a graph object and assign each vertex to the graph by the add_vertex method. To join the vertexes together, you will need to add edges is achieved by passing the two vertexes you want to be joined together and providing a weight value. Printing out the vertex and its connected vertexes, you can loop over the stored vertexes inside the graph object and use another loop over each connection stored within the vertex. Dictionaries in this example are being used to store the vertices and edges of the graph. For more information, you can visit here .","title":"Graphs"},{"location":"data-structures/graphs/#graphs","text":"","title":"Graphs"},{"location":"data-structures/graphs/#description","text":"Graphs data structure formed from vertices/nodes. To connect the vertices/nodes is to use edges. Both vertices/edges can have labels for easier identification. The time complexity for data heavily depends on the number of vertices and edges in the graph. The Big O notation for accessing is O(V+E). Graphs used to represent networks, graphs used within social networks such as Facebook and Linkedin. In social media, each node can be a person.","title":"Description"},{"location":"data-structures/graphs/#example-code","text":"# Code example from https://www.bogotobogo.com/python/python_graph_data_structures.php class Vertex: def __init__(self, node): self.id = node self.adjacent = {} def __str__(self): return str(self.id) + ' adjacent: ' + str([x.id for x in self.adjacent]) def add_neighbor(self, neighbor, weight=0): self.adjacent[neighbor] = weight def get_connections(self): return self.adjacent.keys() def get_id(self): return self.id def get_weight(self, neighbor): return self.adjacent[neighbor] class Graph: def __init__(self): self.vert_dict = {} self.num_vertices = 0 def __iter__(self): return iter(self.vert_dict.values()) def add_vertex(self, node): self.num_vertices = self.num_vertices + 1 new_vertex = Vertex(node) self.vert_dict[node] = new_vertex return new_vertex def get_vertex(self, n): if n in self.vert_dict: return self.vert_dict[n] else: return None def add_edge(self, frm, to, cost = 0): if frm not in self.vert_dict: self.add_vertex(frm) if to not in self.vert_dict: self.add_vertex(to) self.vert_dict[frm].add_neighbor(self.vert_dict[to], cost) self.vert_dict[to].add_neighbor(self.vert_dict[frm], cost) def get_vertices(self): return self.vert_dict.keys() if __name__ == '__main__': g = Graph() g.add_vertex('a') g.add_vertex('b') g.add_vertex('c') g.add_vertex('d') g.add_vertex('e') g.add_vertex('f') g.add_edge('a', 'b', 7) g.add_edge('a', 'c', 9) g.add_edge('a', 'f', 14) g.add_edge('b', 'c', 10) g.add_edge('b', 'd', 15) g.add_edge('c', 'd', 11) g.add_edge('c', 'f', 2) g.add_edge('d', 'e', 6) g.add_edge('e', 'f', 9) for v in g: for w in v.get_connections(): vid = v.get_id() wid = w.get_id() print(('( %s , %s, %3d)' % ( vid, wid, v.get_weight(w)))) for v in g: print(('g.vert_dict[%s]=%s' %(v.get_id(), g.vert_dict[v.get_id()])))","title":"Example Code"},{"location":"data-structures/graphs/#usage","text":"To use this graph data structure, you need a graph object and assign each vertex to the graph by the add_vertex method. To join the vertexes together, you will need to add edges is achieved by passing the two vertexes you want to be joined together and providing a weight value. Printing out the vertex and its connected vertexes, you can loop over the stored vertexes inside the graph object and use another loop over each connection stored within the vertex. Dictionaries in this example are being used to store the vertices and edges of the graph. For more information, you can visit here .","title":"Usage"},{"location":"data-structures/hash-tables/","text":"Hash Tables Description Hash tables use arrays to store information behind the scenes. A hashing function is required to generate an index from a key. The hash table uses this index to store the data in an array. The time complexity for accessing data within a hash table is O(1). Since the data is in an array accessing is quick. Hash tables are used in databases to generate indexes to locate data quickly without traversing the table again. In Python, dictionaries use hash tables. Example Code car1 = { \"brand\": \"McLaren\", \"model\": \"Senna\", \"year\": 2018 } print(car1[\"brand\"]) car2 = { \"brand\": \"Lamborghini\", \"model\": \"Aventador\", \"year\": 2022 } print(car2[\"year\"]) Usage To create dictionaries in Python, you can use curly braces with a string for the key on the left side, separated by a colon and the value you want to store on the right. Separate each entry with a comma. Accessing values from a Python dictionary uses the variable name with having a key surrounded by square brackets. The key must be a string. my_dict[\"something\"] Adding values is the same syntax as above. Assign the value you want to be stored. my_dict[\"something\"] = 123 Additional documentation can be found at here","title":"Hash Tables"},{"location":"data-structures/hash-tables/#hash-tables","text":"","title":"Hash Tables"},{"location":"data-structures/hash-tables/#description","text":"Hash tables use arrays to store information behind the scenes. A hashing function is required to generate an index from a key. The hash table uses this index to store the data in an array. The time complexity for accessing data within a hash table is O(1). Since the data is in an array accessing is quick. Hash tables are used in databases to generate indexes to locate data quickly without traversing the table again. In Python, dictionaries use hash tables.","title":"Description"},{"location":"data-structures/hash-tables/#example-code","text":"car1 = { \"brand\": \"McLaren\", \"model\": \"Senna\", \"year\": 2018 } print(car1[\"brand\"]) car2 = { \"brand\": \"Lamborghini\", \"model\": \"Aventador\", \"year\": 2022 } print(car2[\"year\"])","title":"Example Code"},{"location":"data-structures/hash-tables/#usage","text":"To create dictionaries in Python, you can use curly braces with a string for the key on the left side, separated by a colon and the value you want to store on the right. Separate each entry with a comma. Accessing values from a Python dictionary uses the variable name with having a key surrounded by square brackets. The key must be a string. my_dict[\"something\"] Adding values is the same syntax as above. Assign the value you want to be stored. my_dict[\"something\"] = 123 Additional documentation can be found at here","title":"Usage"},{"location":"data-structures/linked-lists/","text":"Linked Lists Description Linked lists, linear data structure, use nodes with pointer references to the next node. Linked lists are dynamically sizeable, unlike arrays which have a fixed size. The time complexity for accessing data within a linked list is O(\u221aN) GPS navigation systems can use linked lists to store the locations and routes. Example Code # Code from https://www.tutorialspoint.com/python_data_structure/python_linked_lists.htm class Node: def __init__(self, dataval=None): self.dataval = dataval self.nextval = None class SLinkedList: def __init__(self): self.headval = None def listprint(self): printval = self.headval while printval is not None: print (printval.dataval) printval = printval.nextval list1 = SLinkedList() list1.headval = Node(\"Mon\") e2 = Node(\"Tue\") e3 = Node(\"Wed\") # Link first Node to second node list1.headval.nextval = e2 # Link second Node to third node e2.nextval = e3 list1.listprint() Usage To add new elements to a linked list, you must create a node object with the data you would want to be stored. Adding to the linked list would be setting the last node's next reference pointer to the new node. Traversing a linked list can be completed by having a variable for tracking what node you are currently up to with the linked list to start the process, set the variable to the head node. Telling whether you are at the end of the linked list is done by checking if the node's next reference pointer is none. If it is not, you can set the tracking variable to the node's next reference pointer and choose to print out the data value contained within the stored node.","title":"Linked Lists"},{"location":"data-structures/linked-lists/#linked-lists","text":"","title":"Linked Lists"},{"location":"data-structures/linked-lists/#description","text":"Linked lists, linear data structure, use nodes with pointer references to the next node. Linked lists are dynamically sizeable, unlike arrays which have a fixed size. The time complexity for accessing data within a linked list is O(\u221aN) GPS navigation systems can use linked lists to store the locations and routes.","title":"Description"},{"location":"data-structures/linked-lists/#example-code","text":"# Code from https://www.tutorialspoint.com/python_data_structure/python_linked_lists.htm class Node: def __init__(self, dataval=None): self.dataval = dataval self.nextval = None class SLinkedList: def __init__(self): self.headval = None def listprint(self): printval = self.headval while printval is not None: print (printval.dataval) printval = printval.nextval list1 = SLinkedList() list1.headval = Node(\"Mon\") e2 = Node(\"Tue\") e3 = Node(\"Wed\") # Link first Node to second node list1.headval.nextval = e2 # Link second Node to third node e2.nextval = e3 list1.listprint()","title":"Example Code"},{"location":"data-structures/linked-lists/#usage","text":"To add new elements to a linked list, you must create a node object with the data you would want to be stored. Adding to the linked list would be setting the last node's next reference pointer to the new node. Traversing a linked list can be completed by having a variable for tracking what node you are currently up to with the linked list to start the process, set the variable to the head node. Telling whether you are at the end of the linked list is done by checking if the node's next reference pointer is none. If it is not, you can set the tracking variable to the node's next reference pointer and choose to print out the data value contained within the stored node.","title":"Usage"},{"location":"data-structures/lists/","text":"Lists Description A list is an ordered data structure where each element is separated with a comma and wrapped around square brackets. A list use zero-based numbering. The time complexity for accessing data within a list is O(N). Lists can store multiple values under a single variable. Example Code school_subjects = [\"English\", \"Maths\", \"Science\", \"History\"] my_numbers = [25, 45, 65, 83] Lists can have mixed data types mixed_list = [25, True, \"Something\"] Usage To create a list in Python, you use the square brackets within values separated using commas. Adding values, you use the append method to add values to the end of the list or the insert method by passing the index where to insert. For accessing data from a list, you would use an index to retrieve a value. Adding values, you can use this syntax: my_numbers.append(15) or my_numbers.insert(1, 15) # index, value Accessing values, you can use this syntax: my_numbers[0] Additional documentation can be found at here .","title":"Lists"},{"location":"data-structures/lists/#lists","text":"","title":"Lists"},{"location":"data-structures/lists/#description","text":"A list is an ordered data structure where each element is separated with a comma and wrapped around square brackets. A list use zero-based numbering. The time complexity for accessing data within a list is O(N). Lists can store multiple values under a single variable.","title":"Description"},{"location":"data-structures/lists/#example-code","text":"school_subjects = [\"English\", \"Maths\", \"Science\", \"History\"] my_numbers = [25, 45, 65, 83] Lists can have mixed data types mixed_list = [25, True, \"Something\"]","title":"Example Code"},{"location":"data-structures/lists/#usage","text":"To create a list in Python, you use the square brackets within values separated using commas. Adding values, you use the append method to add values to the end of the list or the insert method by passing the index where to insert. For accessing data from a list, you would use an index to retrieve a value. Adding values, you can use this syntax: my_numbers.append(15) or my_numbers.insert(1, 15) # index, value Accessing values, you can use this syntax: my_numbers[0] Additional documentation can be found at here .","title":"Usage"},{"location":"data-structures/queues/","text":"Queues Description A queue is a linear data structure where the first node is the first to leave. The time complexity for accessing elements is 0(N). Traversing the queue is necessary to access a node. A queue data structure multi-threading relies on queues to ensure operations are successful. Example Code # Code example from https://www.geeksforgeeks.org/queue-in-python/ # Python program to # demonstrate queue implementation # using list # Initializing a queue queue = [] # Adding elements to the queue queue.append('a') queue.append('b') queue.append('c') print(\"Initial queue\") print(queue) # Removing elements from the queue print(\"\\nElements dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) print(\"\\nQueue after removing elements\") print(queue) # Uncommenting print(queue.pop(0)) # will raise and IndexError # as the queue is now empty Usage In the example code, you can use a list to provide the storage functionality for the queue. Lists provide the functionality required to add and remove nodes from a queue.","title":"Queues"},{"location":"data-structures/queues/#queues","text":"","title":"Queues"},{"location":"data-structures/queues/#description","text":"A queue is a linear data structure where the first node is the first to leave. The time complexity for accessing elements is 0(N). Traversing the queue is necessary to access a node. A queue data structure multi-threading relies on queues to ensure operations are successful.","title":"Description"},{"location":"data-structures/queues/#example-code","text":"# Code example from https://www.geeksforgeeks.org/queue-in-python/ # Python program to # demonstrate queue implementation # using list # Initializing a queue queue = [] # Adding elements to the queue queue.append('a') queue.append('b') queue.append('c') print(\"Initial queue\") print(queue) # Removing elements from the queue print(\"\\nElements dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) print(\"\\nQueue after removing elements\") print(queue) # Uncommenting print(queue.pop(0)) # will raise and IndexError # as the queue is now empty","title":"Example Code"},{"location":"data-structures/queues/#usage","text":"In the example code, you can use a list to provide the storage functionality for the queue. Lists provide the functionality required to add and remove nodes from a queue.","title":"Usage"},{"location":"data-structures/sets/","text":"Sets Description Sets data structures are unordered and require values stored within to be unique, but there are no restrictions on how many data values are present. Sets in Python use hash tables, so the time complexity for accessing elements would be the access time complexity would be O(1) as finding the location of the stored value is constant time. Sets are for removing duplicated values. Example Code # Code from https://www.programiz.com/python-programming/set # create a set of integer type student_id = {112, 114, 116, 118, 115} print('Student ID:', student_id) # create a set of string type vowel_letters = {'a', 'e', 'i', 'o', 'u'} print('Vowel Letters:', vowel_letters) # create a set of mixed data types mixed_set = {'Hello', 101, -2, 'Bye'} print('Set of mixed data types:', mixed_set) Usage To create a set, use curly braces with the data separated by commas. But using empty curly braces will create an empty dictionary. Creating an empty set without using the set class isn't possible. Python sets come with all the needed methods for accessing and inserting new data. The update method can add data from lists, tuples, and sets quickly and easily. Additional documentation for set methods is here .","title":"Sets"},{"location":"data-structures/sets/#sets","text":"","title":"Sets"},{"location":"data-structures/sets/#description","text":"Sets data structures are unordered and require values stored within to be unique, but there are no restrictions on how many data values are present. Sets in Python use hash tables, so the time complexity for accessing elements would be the access time complexity would be O(1) as finding the location of the stored value is constant time. Sets are for removing duplicated values.","title":"Description"},{"location":"data-structures/sets/#example-code","text":"# Code from https://www.programiz.com/python-programming/set # create a set of integer type student_id = {112, 114, 116, 118, 115} print('Student ID:', student_id) # create a set of string type vowel_letters = {'a', 'e', 'i', 'o', 'u'} print('Vowel Letters:', vowel_letters) # create a set of mixed data types mixed_set = {'Hello', 101, -2, 'Bye'} print('Set of mixed data types:', mixed_set)","title":"Example Code"},{"location":"data-structures/sets/#usage","text":"To create a set, use curly braces with the data separated by commas. But using empty curly braces will create an empty dictionary. Creating an empty set without using the set class isn't possible. Python sets come with all the needed methods for accessing and inserting new data. The update method can add data from lists, tuples, and sets quickly and easily. Additional documentation for set methods is here .","title":"Usage"},{"location":"data-structures/stack/","text":"Stack Description A stack is a linear data structure, defined by the last node entering a stack is the first one popped from a stack. You can access elements of a stack in the total time O(1). Requires traversing the stack. A stack data structure is for functionality that requires going back and forth. In your browser, forward and back navigation buttons work on a stack. Example Code class Stack: stack = [] def is_empty(self) -> bool: return self.length() == 0 def length(self) -> int: return len(self.stack) def pop(self) -> None: count = self.length() if count == 0: return item = self.stack[-1] self.stack.pop() return item def push(self, value: any) -> None: if value is None: return if type(value) is not int: return self.stack.insert(0, value) def peek(self) -> any: if self.is_empty(): return return self.stack[-1] def list(self) -> any: return self.stack def clear(self) -> any: self.stack = [] def __str__(self) -> str: return f\"The length of the stack is {self.length()}. The number on top is {self.peek()}.\" Usage Adding new nodes in the stack, you would use the push method to add the node you've provided. To remove the last node in the stack, you can use the pop method to remove the end node and return it. To view the top node without popping a node from the stack, you can use the peek method will return the last node in the stack.","title":"Stack"},{"location":"data-structures/stack/#stack","text":"","title":"Stack"},{"location":"data-structures/stack/#description","text":"A stack is a linear data structure, defined by the last node entering a stack is the first one popped from a stack. You can access elements of a stack in the total time O(1). Requires traversing the stack. A stack data structure is for functionality that requires going back and forth. In your browser, forward and back navigation buttons work on a stack.","title":"Description"},{"location":"data-structures/stack/#example-code","text":"class Stack: stack = [] def is_empty(self) -> bool: return self.length() == 0 def length(self) -> int: return len(self.stack) def pop(self) -> None: count = self.length() if count == 0: return item = self.stack[-1] self.stack.pop() return item def push(self, value: any) -> None: if value is None: return if type(value) is not int: return self.stack.insert(0, value) def peek(self) -> any: if self.is_empty(): return return self.stack[-1] def list(self) -> any: return self.stack def clear(self) -> any: self.stack = [] def __str__(self) -> str: return f\"The length of the stack is {self.length()}. The number on top is {self.peek()}.\"","title":"Example Code"},{"location":"data-structures/stack/#usage","text":"Adding new nodes in the stack, you would use the push method to add the node you've provided. To remove the last node in the stack, you can use the pop method to remove the end node and return it. To view the top node without popping a node from the stack, you can use the peek method will return the last node in the stack.","title":"Usage"},{"location":"data-structures/trees/","text":"Trees Description The data structure represents a tree. Organising data in this way makes it easy to navigate and search through. The tree consists of nodes and branches. Each node can only have one parent. The time complexity for accessing elements is 0(N). Traversing the tree is necessary to access a node. Data compression uses binary trees to provide efficient storage space optimisation. Example Code # Code example from https://www.tutorialspoint.com/python_data_structure/python_binary_tree.htm class Node: def __init__(self, data): self.left = None self.right = None self.data = data # Insert Node def insert(self, data): if self.data: if data < self.data: if self.left is None: self.left = Node(data) else: self.left.insert(data) elif data > self.data: if self.right is None: self.right = Node(data) else: self.right.insert(data) else: self.data = data # Print the Tree def PrintTree(self): if self.left: self.left.PrintTree() print(self.data) if self.right: self.right.PrintTree() # Inorder traversal # Left -> Root -> Right def inorderTraversal(self, root): res = [] if root: res = self.inorderTraversal(root.left) res.append(root.data) res = res + self.inorderTraversal(root.right) return res root = Node(27) root.insert(14) root.insert(35) root.insert(10) root.insert(19) root.insert(31) root.insert(42) print(root.inorderTraversal(root)) Usage Creating a tree requires a starting point node. You can use the insert method for adding additional nodes, which will check whether the data should go on the left or right. Printing out values uses the inorder traversal way of navigating a tree once done, it will print out an array with the data stored in the nodes.","title":"Trees"},{"location":"data-structures/trees/#trees","text":"","title":"Trees"},{"location":"data-structures/trees/#description","text":"The data structure represents a tree. Organising data in this way makes it easy to navigate and search through. The tree consists of nodes and branches. Each node can only have one parent. The time complexity for accessing elements is 0(N). Traversing the tree is necessary to access a node. Data compression uses binary trees to provide efficient storage space optimisation.","title":"Description"},{"location":"data-structures/trees/#example-code","text":"# Code example from https://www.tutorialspoint.com/python_data_structure/python_binary_tree.htm class Node: def __init__(self, data): self.left = None self.right = None self.data = data # Insert Node def insert(self, data): if self.data: if data < self.data: if self.left is None: self.left = Node(data) else: self.left.insert(data) elif data > self.data: if self.right is None: self.right = Node(data) else: self.right.insert(data) else: self.data = data # Print the Tree def PrintTree(self): if self.left: self.left.PrintTree() print(self.data) if self.right: self.right.PrintTree() # Inorder traversal # Left -> Root -> Right def inorderTraversal(self, root): res = [] if root: res = self.inorderTraversal(root.left) res.append(root.data) res = res + self.inorderTraversal(root.right) return res root = Node(27) root.insert(14) root.insert(35) root.insert(10) root.insert(19) root.insert(31) root.insert(42) print(root.inorderTraversal(root))","title":"Example Code"},{"location":"data-structures/trees/#usage","text":"Creating a tree requires a starting point node. You can use the insert method for adding additional nodes, which will check whether the data should go on the left or right. Printing out values uses the inorder traversal way of navigating a tree once done, it will print out an array with the data stored in the nodes.","title":"Usage"}]}